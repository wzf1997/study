<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>

// const map = new Map([
//   ['name', '张三'],
//   ['title', 'Author']
// ]);
// const map= new Set([{"title":1},{"title2":2}])

// const  m1=new Map(map)
// console.log(m1)
// map.size // 2
// map.has('name') // true
// map.get('name') // "张三"
// map.has('title') // true
// map.get('title') // "Author"

// const set = new Set([
//   ['foo', 1],
//   ['bar', 2]
// ]);
// const m1 = new Map(set);
// console.log(m1)
// m1.get('foo') // 1

// const map= new Map([
//     ["fool",2],
//     ["teztx",3]
// ])
// console.log(map)

// map 数据结构中   key 的设置 本质上是 如果key  是基本数据类型  只要 两个值
// 严格相等的时候  -0  和 0 就是一样的    true  和”true“  就是不一样的  
// null  和 undefined  也是不一样的   但是有一个比较特殊 就是 NaN 是表示相等的
// 复杂数据类型 比较的是内存地址  内存地址不一样 获得的value  就是不一样的 

// const map = new Map();

// map.set(['a'], 555);
// map.get(['a']) // undefined
// console.log(map)

// map 原型链上的一些方法  
// const map = new Map([
//   ['F', 'no'],
//   ['T',  'yes'],
// ]);
// console.log(map)
// console.log( map.keys() )
// console.log( map.entries())


// for(let elem of map){
//     console.log(elem)
// }
// for(let elem of map.keys()){
//     console.log(elem)
// }
// for(let elem of map.values()){
//     console.log(elem)
// }  


    </script>
</body>
</html>